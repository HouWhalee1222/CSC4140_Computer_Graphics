<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Ray Tracing： Part 2</title><meta http-equiv="Content-Language" content="en"><link rel="stylesheet" href="./part2_files/ionicons.min.css">
<link rel="stylesheet" href="./part1_files/web-5d805804.css">
<link rel="stylesheet" href="./part2_files/katex.min.css">
<link rel="stylesheet" href="./part2_files/github-markdown.css">
<link rel="stylesheet" href="./part2_files/github.min.css"><style type="text/css">date-input-polyfill{background:#fff;color:#000;text-shadow:none;border:0;padding:0;height:auto;width:auto;line-height:normal;font-family:sans-serif;font-size:14px;position:absolute!important;text-align:center;box-shadow:0 3px 10px 1px rgba(0,0,0,.22);cursor:default;z-index:1;border-radius:5px;-moz-border-radius:5px;-webkit-border-radius:5px;overflow:hidden;display:block}date-input-polyfill[data-open=false]{visibility:hidden;z-index:-100!important;top:0}date-input-polyfill[data-open=true]{visibility:visible}date-input-polyfill select,date-input-polyfill table,date-input-polyfill td,date-input-polyfill th{background:#fff;color:#000;text-shadow:none;border:0;padding:0;height:auto;width:auto;line-height:normal;font-family:sans-serif;font-size:14px;box-shadow:none;font-family:Lato,Helvetica,Arial,sans-serif}date-input-polyfill button,date-input-polyfill select{border:0;border-radius:0;border-bottom:1px solid #dadfe1;height:24px;vertical-align:top;-webkit-appearance:none;-moz-appearance:none}date-input-polyfill .monthSelect-wrapper{width:55%;display:inline-block}date-input-polyfill .yearSelect-wrapper{width:25%;display:inline-block}date-input-polyfill select{width:100%}date-input-polyfill select:first-of-type{border-right:1px solid #dadfe1;border-radius:5px 0 0 0;-moz-border-radius:5px 0 0 0;-webkit-border-radius:5px 0 0 0}date-input-polyfill button{width:20%;background:#dadfe1;border-radius:0 5px 0 0;-moz-border-radius:0 5px 0 0;-webkit-border-radius:0 5px 0 0}date-input-polyfill button:hover{background:#eee}date-input-polyfill table{border-collapse:separate!important;border-radius:0 0 5px 5px;-moz-border-radius:0 0 5px 5px;-webkit-border-radius:0 0 5px 5px;overflow:hidden;max-width:280px;width:280px}date-input-polyfill td,date-input-polyfill th{width:32px;padding:4px;text-align:center;box-sizing:content-box}date-input-polyfill td[data-day]{cursor:pointer}date-input-polyfill td[data-day]:hover{background:#dadfe1}date-input-polyfill [data-selected]{font-weight:700;background:#d8eaf6}</style></head><body><script>$MG={"browserRefresh":false,"activeSemester":{"id":7,"tag":"sp22"},"auth":{"profile":null},"semester":{"id":7,"tag":"sp22"}}</script><div id="app-root"><div class="rel" id="app-page"><header class="rel" id="app-header"></header><div class="full" id="app-page__body"><div class="article"><div class="article-header"><h1>Part 2: Bounding Volume Hierarchy</h1></div><div class="article-body"><div class="comp-md markdown-body"><h2>Task 0: Timing Experiment</h2>
<p>You may notice that, even with basic normal shading, any .dae files with even mildly complicated geometries takes a very long time to render. In Part 2, we will implement a Bounding Volume Hierarchy (BVH) to speed up our path tracer so that it can render these <em>.dae</em> files a lot more efficiently.</p>
<p>For example, try running your path tracer on the following mesh from Assignment 2:</p>
<pre><code>./pathtracer -t 8 -r 800 600 -f cow.png ../dae/meshedit/cow.dae
</code></pre>
<p><strong>This will take quite some time to complete!</strong> The reference solution with only Part 1 completed took 40 seconds to render the image on a Hive machine. The reason rendering takes this long is because the starter code only creates a one-node BVH and stores all triangles and spheres directly into the leaf node. As we will see, a BVH constructed with just simple heuristics will still perform much better, taking ray intersection complexity from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Task 1: Constructing the BVH</h2>
<p>Fill in <code>BVHAccel:construct_bvh(...)</code> inside <em>src/scene/bvh.cpp</em>.</p>
<p>A BVH is a binary tree. The <code>BVHAccel</code> class itself only contains the root node <code>BVHNode *root</code>. Each node in the tree contains (1) a bounding box <code>bb</code>, (2) left and right children <code>l</code> and <code>r</code>, and (3) two iterators <code>start</code> and <code>end</code> pointing to the beginning and the end of a list of actual scene primitives. For interior nodes, <code>l</code> and <code>r</code> are non-<code>NULL</code>; and for leaf nodes, <code>start</code> and <code>end</code> are non-<code>NULL</code>.</p>
<p>Recall BVH allows us to traverse the scene and quickly discard collections of primitives that a particular ray is guaranteed <strong>not</strong> to intersect. We recommend that you construct the BVH recursively.</p>
<p>First, compute the bounding box of a list of primitives and initialize a new <code>BVHNode</code> with that bounding box. If there are no more than <code>max_leaf_size</code> primitives in the list, the node we just created is a leaf node and we should update its <code>start</code> and <code>end</code> iterators appropriately. (Please think carefully about how you would update the iterators.) Return this leaf node to end the recursion.</p>
<p>Otherwise, we need to divide the primitives into a "left" and "right" collection. Remember that the primitives and their bounding boxes exist in 3D, so we want to split along the axis that gives us the most benefit. Compute the split point along this axis and use it to divide all primitives into a "left" and "right" collection based on the centroid of their bounding boxes. Set the current node's left and right children by recursively calling <code>BVHAccel:construct_bvh(...)</code>.</p>
<p>You may find the following functions helpful:</p>
<ol>
<li><code>Primitive::get_bbox()</code> returns the bounding box of a primitive.</li>
<li><code>Primitive::get_bbox().centroid()</code> returns the centroid of the bounding box of a primitive.</li>
<li><code>BBox::expand(...)</code> expands a bounding box to include the function input, which can either be a <code>Vector3D</code> or another <code>BBox</code>.</li>
</ol>
<p><strong>Implementation Notes:</strong></p>
<ul>
<li>Suggestions for the split point include the midpoint of an axis or the average of centroids along an axis.</li>
<li>If the split point is chosen such that all primitives lie on only one side of the split point, you will get a segfault because of infinite recursive calls. (Can you reason why infinite recursive calls happen in this case?) You can handle it with any reasonable logic.</li>
<li>Feel free to experiment with other BVH construction methods. Some ideas include changing the splitting heuristic (e.g., using the median primitive, using some surface area heuristic, and etc) or improving the algorithmic or memory efficiency of your BVH. See the <a href="./part2_extra.html">extra credit</a> section for more.</li>
</ul>
<p><strong>Sanity Check:</strong></p>
<p>The GUI provides a helpful BVH visualization mode that you can use to debug your implementation. You can press <kbd>V</kbd> to enter this mode and you start at the root of your BVH. At any node, you can use <kbd>←</kbd>, <kbd>→</kbd>, or <kbd>↑</kbd> to navigate to the left child node, to the right child node, or back to the parent node. The BVH visualization mode looks like the following:</p>
<p style="text-align:center">
    <img src="./part2_files/umnQABt.jpg" width="640px">
</p>
<h2>Task 2: Intersecting the Bounding Box</h2>
<p>Fill in <code>BBox::intersect(...)</code> in <em>src/scene/bbox.cpp</em>.</p>
<p>This function takes a ray as input and updates the input <code>t0</code> and <code>t1</code> with the interval of <code>t</code> values for which the ray lies within the box. You may use the ray and axis-aligned plane intersection equations, as well as the ray and axis-aligned box intersection method .</p>
<h2>Task 3: Intersecting the BVH</h2>
<p>Fill in <code>BVHAccel::has_intersection(...)</code> and <code>BVHAccel::intersect(...)</code> in <em>src/scene/bvh.cpp</em>.</p>
<p><code>BVHAccel::has_intersection(...)</code> simply tests whether there is an intersection between the input ray and <strong>any</strong> primitives in the input BVH. <code>BVHAccel::intersect(...)</code> not only tests for intersection, but also reports the nearest intersection via the input <code>Intersection *i</code> structure. You can use these functions as helper functions for each other if that helps simplify your code.</p>
<p>The starter code assumes that the root node is the leaf node and tests the ray against every single primitive in the tree. Your improved method should implement this recursive traversal algorithm.</p>
<p><strong>Implementation Notes:</strong></p>
<ul>
<li>You can safely return <code>false</code> if a ray intersects with a <code>BBox</code> but its <code>t</code> interval has an empty intersection with the ray's valid interval from <code>min_t</code> to <code>max_t</code>. However, be careful about what you pass in as <code>t0</code> and <code>t1</code> since those variables will get changed!</li>
<li>For <code>BVHAccel::has_intersection(...)</code>, you can safely return <code>true</code> after a single intersection. However, for <code>BVHAccel::intersect(...)</code>, you need to return the nearest intersection along the ray, so you must check every primitives in every <code>BBox</code> intersected by the ray. (Can you reason why is this true?)</li>
<li>If all primitives update <code>i</code> and <code>r.max_t</code> correctly in their own intersection functions, you do not need to worry about updating them in your BVH intersection functions. (Can you reason why this works?)</li>
<li>If a ray starts or ends within a <code>BBox</code>, that counts as a valid intersection</li>
</ul>
<p><strong>Sanity Check:</strong></p>
<p>Let us go back and see how long your path tracer now takes to render the same mesh from earlier:</p>
<pre><code>./pathtracer -t 8 -r 800 600 -f cow.png ../dae/meshedit/cow.dae
</code></pre>
<p>The reference solution took 0.173 seconds, as opposed to 40 seconds, to render the image on a Hive machine</p>
<p>Once Task 3 is complete, your path tracer should be fast enough to render any of our scene files in a matter of seconds (with normal shading only), even ones like <em>dae/meshedit/maxplanck.dae</em> with tens of thousands of triangles:</p>
<p style="text-align:center">
    <img src="./part2_files/7IV6YTv.png" width="640px">
</p>
<p>Or <em>dae/sky/CBlucy.dae</em> with hundreds of thousands of triangles. The reference solution took 1.67 seconds to render this image on a Hive machine.</p>
<p style="text-align:center">
    <img src="./part2_files/pn6ohpX.png" width="640px">
</p>
<p>Take a moment to refresh yourself on the <a href="https://cs184.eecs.berkeley.edu/sp22/docs/proj3-1-writeup">deliverable</a> requirements and conduct some performance comparison experiments of your new BVH-accelerated intersection algorithm!</p>
</div></div></div></div><footer id="app-footer"></footer></div></div><script src="./part2_files/cs184-web-a09c6a18.js.下载"></script>
<script>$_mod_cal184.ready();</script><date-input-polyfill data-open="false"><span class="yearSelect-wrapper"><select class="yearSelect"><option value="1890">1890</option><option value="1891">1891</option><option value="1892">1892</option><option value="1893">1893</option><option value="1894">1894</option><option value="1895">1895</option><option value="1896">1896</option><option value="1897">1897</option><option value="1898">1898</option><option value="1899">1899</option><option value="1900">1900</option><option value="1901">1901</option><option value="1902">1902</option><option value="1903">1903</option><option value="1904">1904</option><option value="1905">1905</option><option value="1906">1906</option><option value="1907">1907</option><option value="1908">1908</option><option value="1909">1909</option><option value="1910">1910</option><option value="1911">1911</option><option value="1912">1912</option><option value="1913">1913</option><option value="1914">1914</option><option value="1915">1915</option><option value="1916">1916</option><option value="1917">1917</option><option value="1918">1918</option><option value="1919">1919</option><option value="1920">1920</option><option value="1921">1921</option><option value="1922">1922</option><option value="1923">1923</option><option value="1924">1924</option><option value="1925">1925</option><option value="1926">1926</option><option value="1927">1927</option><option value="1928">1928</option><option value="1929">1929</option><option value="1930">1930</option><option value="1931">1931</option><option value="1932">1932</option><option value="1933">1933</option><option value="1934">1934</option><option value="1935">1935</option><option value="1936">1936</option><option value="1937">1937</option><option value="1938">1938</option><option value="1939">1939</option><option value="1940">1940</option><option value="1941">1941</option><option value="1942">1942</option><option value="1943">1943</option><option value="1944">1944</option><option value="1945">1945</option><option value="1946">1946</option><option value="1947">1947</option><option value="1948">1948</option><option value="1949">1949</option><option value="1950">1950</option><option value="1951">1951</option><option value="1952">1952</option><option value="1953">1953</option><option value="1954">1954</option><option value="1955">1955</option><option value="1956">1956</option><option value="1957">1957</option><option value="1958">1958</option><option value="1959">1959</option><option value="1960">1960</option><option value="1961">1961</option><option value="1962">1962</option><option value="1963">1963</option><option value="1964">1964</option><option value="1965">1965</option><option value="1966">1966</option><option value="1967">1967</option><option value="1968">1968</option><option value="1969">1969</option><option value="1970">1970</option><option value="1971">1971</option><option value="1972">1972</option><option value="1973">1973</option><option value="1974">1974</option><option value="1975">1975</option><option value="1976">1976</option><option value="1977">1977</option><option value="1978">1978</option><option value="1979">1979</option><option value="1980">1980</option><option value="1981">1981</option><option value="1982">1982</option><option value="1983">1983</option><option value="1984">1984</option><option value="1985">1985</option><option value="1986">1986</option><option value="1987">1987</option><option value="1988">1988</option><option value="1989">1989</option><option value="1990">1990</option><option value="1991">1991</option><option value="1992">1992</option><option value="1993">1993</option><option value="1994">1994</option><option value="1995">1995</option><option value="1996">1996</option><option value="1997">1997</option><option value="1998">1998</option><option value="1999">1999</option><option value="2000">2000</option><option value="2001">2001</option><option value="2002">2002</option><option value="2003">2003</option><option value="2004">2004</option><option value="2005">2005</option><option value="2006">2006</option><option value="2007">2007</option><option value="2008">2008</option><option value="2009">2009</option><option value="2010">2010</option><option value="2011">2011</option><option value="2012">2012</option><option value="2013">2013</option><option value="2014">2014</option><option value="2015">2015</option><option value="2016">2016</option><option value="2017">2017</option><option value="2018">2018</option><option value="2019">2019</option><option value="2020">2020</option><option value="2021">2021</option><option value="2022">2022</option><option value="2023">2023</option><option value="2024">2024</option><option value="2025">2025</option><option value="2026">2026</option><option value="2027">2027</option><option value="2028">2028</option><option value="2029">2029</option><option value="2030">2030</option><option value="2031">2031</option><option value="2032">2032</option><option value="2033">2033</option><option value="2034">2034</option><option value="2035">2035</option><option value="2036">2036</option><option value="2037">2037</option><option value="2038">2038</option><option value="2039">2039</option><option value="2040">2040</option><option value="2041">2041</option><option value="2042">2042</option></select></span><span class="monthSelect-wrapper"><select class="monthSelect"></select></span><button>Today</button><table><thead></thead><tbody></tbody></table></date-input-polyfill></body></html>